{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home ProfileService is a stand-alone ModuleScript that specialises in loading and auto-saving DataStore profiles. A DataStore Profile (Later referred to as just Profile ) is a set of data which is meant to be loaded up only once inside a Roblox server and then written to and read from locally on that server (With no delays associated with talking with the DataStore every time data changes) whilst being periodically auto-saved and saved immediately once after the server finishes working with the Profile . The benefits of using ProfileService for your game's profiles are: Easy to learn, and eventually forget - ProfileService does not give you any data getter or setter functions. It gives you the freedom to write your own data interface. Built for massive scalability - low resource footprint, no excessive type checking. Great for 100+ player servers. ProfileService automatically spreads the DataStore API calls evenly within the auto-save loop timeframe. Already does the things you wouldn't dare script yourself (but should) - session-locking is essential to keeping your data protected from multiple server editing - this is a potential cause of item loss or item duplication loopholes. ProfileService offers a very comprehensive and short API for handling session-locking yourself or just letting ProfileService do it automatically for you. Future-proof - with features like MetaTags and GlobalUpdates , you will always be able to add new functionality to your profiles without headaches. Made for ambitious projects - ProfileService is a profile object abstraction detached from the Player instance - this allows the developer to create profiles for entities other than players, such as: group-owned houses, savable multiplayer game instances, etc. If anything is missing or broken, file an issue on GitHub . If you need help integrating ProfileService into your project, join the discussion . Disclaimer : Although ProfileService has been thoroughly tested (Auto testing source included - ProfileTest.lua ), it has not been used within a large scale Roblox project yet. ProfileService is the successor to an earlier DataStore implementation used in The Mad Murderer 2 Why not DataStore2? DataStore2 is mostly a Roblox DataStore wrapper module which automatically saves duplicates of your data. ProfileService is an extension module which gives you powerful tools to manage profile session-locking, cross server gifting and profile data organizing. ProfileService protects your data only from the relevant Roblox server problems. It's completely stacked when it comes to protecting your game data from item duplication exploits . ProfileService is striving to be a DataStore solution that is the most accurate implementation of data storage following the development guidelines and practices provided in the official Roblox API .","title":"Home"},{"location":"#home","text":"ProfileService is a stand-alone ModuleScript that specialises in loading and auto-saving DataStore profiles. A DataStore Profile (Later referred to as just Profile ) is a set of data which is meant to be loaded up only once inside a Roblox server and then written to and read from locally on that server (With no delays associated with talking with the DataStore every time data changes) whilst being periodically auto-saved and saved immediately once after the server finishes working with the Profile . The benefits of using ProfileService for your game's profiles are: Easy to learn, and eventually forget - ProfileService does not give you any data getter or setter functions. It gives you the freedom to write your own data interface. Built for massive scalability - low resource footprint, no excessive type checking. Great for 100+ player servers. ProfileService automatically spreads the DataStore API calls evenly within the auto-save loop timeframe. Already does the things you wouldn't dare script yourself (but should) - session-locking is essential to keeping your data protected from multiple server editing - this is a potential cause of item loss or item duplication loopholes. ProfileService offers a very comprehensive and short API for handling session-locking yourself or just letting ProfileService do it automatically for you. Future-proof - with features like MetaTags and GlobalUpdates , you will always be able to add new functionality to your profiles without headaches. Made for ambitious projects - ProfileService is a profile object abstraction detached from the Player instance - this allows the developer to create profiles for entities other than players, such as: group-owned houses, savable multiplayer game instances, etc. If anything is missing or broken, file an issue on GitHub . If you need help integrating ProfileService into your project, join the discussion . Disclaimer : Although ProfileService has been thoroughly tested (Auto testing source included - ProfileTest.lua ), it has not been used within a large scale Roblox project yet. ProfileService is the successor to an earlier DataStore implementation used in The Mad Murderer 2","title":"Home"},{"location":"#why-not-datastore2","text":"DataStore2 is mostly a Roblox DataStore wrapper module which automatically saves duplicates of your data. ProfileService is an extension module which gives you powerful tools to manage profile session-locking, cross server gifting and profile data organizing. ProfileService protects your data only from the relevant Roblox server problems. It's completely stacked when it comes to protecting your game data from item duplication exploits . ProfileService is striving to be a DataStore solution that is the most accurate implementation of data storage following the development guidelines and practices provided in the official Roblox API .","title":"Why not DataStore2?"},{"location":"api/","text":"Warning Never yield (use wait() or asynchronous Roblox API calls) inside listener functions Notice Methods with Async in their name are methods that will yield - just like wait() ProfileService ProfileService.ServiceLocked ProfileService . ServiceLocked [ bool ] Set to false when the Roblox server is shutting down. ProfileStore methods should not be called after this value is set to false ProfileService.IssueSignal ProfileService . IssueSignal [ ScriptSignal ]( error_message [ string ], profile_store_name [ string ], profile_key [ string ]) Analytics endpoint for DataStore error logging. Example usage: ProfileService . IssueSignal : Connect ( function ( error_message , profile_store_name , profile_key ) pcall ( function () AnalyticsService : FireEvent ( \"ProfileServiceIssue\" , error_message , profile_store_name , profile_key ) end ) end ) ProfileService.CorruptionSignal ProfileService . CorruptionSignal [ ScriptSignal ]( profile_store_name [ string ], profile_key [ string ]) Analytics endpoint for cases when a DataStore key returns a value that has all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a non table value ProfileService.CriticalStateSignal ProfileService . CriticalStateSignal [ ScriptSignal ] ( is_critical_state [ bool ]) Analytics endpoint for cases when DataStore is throwing too many errors and it's most likely affecting your game really really bad - this could be due to developer errors or due to Roblox server problems. Could be used to alert players about data store outages. ProfileService.GetProfileStore() ProfileService . GetProfileStore ( profile_store_index , profile_template ) --> [ProfileStore] -- profile_store_index [string] -- DataStore name -- OR -- profile_store_index [table]: -- Allows the developer to define more GlobalDataStore variables -- { -- Name = \"StoreName\", -- [string] -- DataStore name -- -- Optional arguments: -- Scope = \"StoreScope\", -- [string] -- DataStore scope -- } -- profile_template [table] -- Profile.Data will default to -- given table (deep-copy) when no data was saved previously ProfileStore objects expose methods for loading / viewing profiles and sending global updates. Equivalent of :GetDataStore() in Roblox DataStoreService API. Notice By default, profile_template is only copied for Profile.Data for new profiles. Changes made to profile_template can be applied to Profile.Data of previously saved profiles by calling Profile:Reconcile() . You can also create your own function to fill in the missing components in Profile.Data as soon as it is loaded or have nil exceptions in your personal :Get() and :Set() method libraries. ProfileStore ProfileStore:LoadProfileAsync() ProfileStore : LoadProfileAsync ( profile_key , not_released_handler ) --> [Profile] or nil -- profile_key [string] -- DataStore key -- not_released_handler nil or []: -- Defaults to \"ForceLoad\" -- [string] \"ForceLoad\" -- Force loads profile on first call -- OR -- [string] \"Steal\" -- Steals the profile ignoring it's session lock -- OR -- [function] (place_id, game_job_id) --> [string] \"Repeat\", \"Cancel\", \"ForceLoad\" or \"Steal\" -- place_id [number] or nil -- game_job_id [string] or nil For basic usage, pass nil for the not_released_handler argument. not_released_handler as a function argument is called when the profile is session-locked by a remote Roblox server: local profile = ProfileStore : LoadProfileAsync ( \"Player_2312310\" , function ( place_id , game_job_id ) -- place_id and game_job_id identify the Roblox server that has -- this profile currently locked. In rare cases, if the server -- crashes, the profile will stay locked until ForceLoaded by -- a new session. return \"Repeat\" or \"Cancel\" or \"ForceLoad\" or \"Steal\" end ) not_released_handler must return one of the following values: return \"Repeat\" - ProfileService will repeat the profile loading proccess and may call the release handler again return \"Cancel\" - :LoadProfileAsync() will immediately return nil return \"ForceLoad\" - ProfileService will indefinitely attempt to load the profile. If the profile is session-locked by a remote Roblox server, it will either be released for that remote server or \"stolen\" (Stealing is necessary for remote servers that are not responding in time and for handling crashed server session-locks). return \"Steal\" - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying a session lock for this session. \"Steal\" can be used to clear dead session locks faster than \"ForceLoad\" assuming your code knows that the session lock is dead. Notice ProfileService saves profiles to live DataStore keys in Roblox Studio when Roblox API services are enabled . See ProfileStore.Mock if saving to live keys during testing is not desired. Warning :LoadProfileAsync() can return nil when another remote Roblox server attempts to load the profile at the same time. This case should be extremely rare and it would be recommended to :Kick() the player if :LoadProfileAsync() does not return a Profile object. Do not load a profile of the same key again before it is released Trying to load a profile that has already been session-locked on the same server will result in an error. You may, however, instantly load the profile again after releasing it with Profile:Release() . ProfileStore:GlobalUpdateProfileAsync() ProfileStore : GlobalUpdateProfileAsync ( profile_key , update_handler ) --> [GlobalUpdates] or nil -- profile_key [string] -- DataStore key -- update_handler [function](global_updates) -- This function is -- called with a GlobalUpdates object Used to create and manage Active global updates for a specified Profile . Can be called on any Roblox server of your game. Updates should reach the recipient in less than 30 seconds, regardless of whether it was called on the same server the Profile is session-locked to. See Global Updates for more information. Example usage of :GlobalUpdateProfileAsync() : ProfileStore : GlobalUpdateProfileAsync ( \"Player_2312310\" , function ( global_updates ) global_updates : AddActiveUpdate ({ Type = \"AdminGift\" , Item = \"Coins\" , Amount = 1000 , }) end ) Notice :GlobalUpdateProfileAsync() will work for profiles that haven't been created (profiles are created when they're loaded using :LoadProfileAsync() for the first time) Yielding inside the update_handler function will throw an error Avoid rapid use of ProfileStore:GlobalUpdateProfileAsync() Excessive use of ProfileStore:GlobalUpdateProfileAsync() can lead to dead session locks and event lost Profile.Data (latter is mostly possible only if the Profile is loaded in the same session as :GlobalUpdateProfileAsync() is called). This is due to a queue system that executes every write request for the Profile every 7 seconds - if this queue grows larger than the BindToClose timeout (approx. 30 seconds), some requests in the queue can be lost after the game shuts down. ProfileStore:ViewProfileAsync() ProfileStore : ViewProfileAsync ( profile_key , version ) --> [Profile] or nil -- profile_key [string] -- DataStore key -- version nil or [string] -- DataStore key version Passing version argument in mock mode (Or offline mode) will throw an error - Mock versioning is not supported Attempts to load the latest profile version (or a specified version via the version argument) from the DataStore without claiming a session lock. Returns nil if such version does not exist. Returned Profile will not auto-save and releasing won't do anything. Data in the returned Profile can be changed to create a payload which can be saved via Profile:OverwriteAsync() . :ViewProfileAsync() is the the prefered way of viewing player data without editing it. ProfileStore:ProfileVersionQuery() ProfileStore : ProfileVersionQuery ( profile_key , sort_direction , min_date , max_date ) --> [ProfileVersionQuery] -- profile_key [string] -- sort_direction nil or [Enum.SortDirection] -- Defaults to \"Ascending\" -- min_date nil or [DateTime] or [number] (epoch time millis) -- max_date nil or [DateTime] or [number] (epoch time millis) Creates a profile version query using DataStore:ListVersionsAsync() (Official documentation) . Results are retrieved through ProfileVersionQuery:Next() . For additional help, check the versioning example in official Roblox documentation . Date definitions are easier with the DateTime (Official documentation) library. User defined day and time will have to be converted to Unix time (Wikipedia) while taking their timezone into account to expect the most precise results, though you can be rough and just set the date and time in the UTC timezone and expect a maximum margin of error of 24 hours for your query results. Examples of query arguments: Pass nil for sort_direction , min_date and max_date to find the oldest available version Pass Enum.SortDirection.Descending for sort_direction , nil for min_date and max_date to find the most recent version. Pass Enum.SortDirection.Descending for sort_direction , nil for min_date and DateTime defining a time before an event (e.g. two days earlier before your game unrightfully stole 1,000,000 rubies from a player) for max_date to find the most recent version of a Profile that existed before said event. Case example: \"I lost all of my rubies on August 14th!\" -- Get a ProfileStore object with the same arguments you passed to the -- ProfileStore that loads player Profiles. It can also just be -- the very same ProfileStore object: local ProfileStore = ProfileService . GetProfileStore ( store_name , template ) -- If you can't figure out the exact time and timezone the player lost rubies -- in on the day of August 14th, then your best bet is to try querying -- UTC August 13th. If the first entry still doesn't have the rubies - -- try a new query of UTC August 12th and etc. local max_date = DateTime . fromUniversalTime ( 2021 , 08 , 13 ) -- UTC August 13th, 2021 local query = ProfileStore : ProfileVersionQuery ( \"Player_2312310\" , -- The same profile key that gets passed to :LoadProfileAsync() Enum . SortDirection . Descending , nil , max_date ) -- Get the first result in the query: local profile = query : NextAsync () if profile ~= nil then profile : ClearGlobalUpdates () profile : OverwriteAsync () -- This method does the actual rolling back; -- Don't call this method until you're sure about setting the latest -- version to a copy of the previous one print ( \"Rollback success!\" ) print ( profile . Data ) -- You'll be able to surf table contents if -- you're runing this code in studio with access to API services -- enabled and have expressive output enabled; If the printed -- data doesn't have the rubies, you'll want to change your -- query parameters. else print ( \"No version to rollback to\" ) end Case example: Studying data mutation over time -- You have ProfileService working in your game. You join -- the game with your own account and go to https://www.unixtimestamp.com -- and save the current UNIX timestamp resembling present time. -- You can then make the game alter your data by giving you -- currency, items, experience, etc. local ProfileStore = ProfileService . GetProfileStore ( store_name , template ) -- UNIX timestamp you saved: local min_date = DateTime . fromUnixTimestamp ( 1628952101 ) local print_minutes = 5 -- Print the next 5 minutes of history local query = ProfileStore : ProfileVersionQuery ( \"Player_2312310\" , Enum . SortDirection . Ascending , min_date ) -- You can now attempt to print out every snapshot of your data saved -- at an average periodic interval of 30 seconds (ProfileService auto-save) -- starting from the time you took the UNIX timestamp! local finish_update_time = min_date . UnixTimestampMillis + ( print_minutes * 60000 ) print ( \"Fetching \" , print_minutes , \"minutes of saves:\" ) local entry_count = 0 while true do entry_count += 1 local profile = query : NextAsync () if profile ~= nil then if profile . KeyInfo . UpdatedTime > finish_update_time then if entry_count == 1 then print ( \"No entries found in set time period. (Start timestamp too early)\" ) else print ( \"Time period finished.\" ) end break end print ( \"Entry\" , entry_count , \"-\" , DateTime . fromUnixTimestampMillis ( profile . KeyInfo . UpdatedTime ): ToIsoDate () ) print ( profile . Data ) -- Printing table for studio expressive output else if entry_count == 1 then print ( \"No entries found in set time period. (Start timestamp too late)\" ) else print ( \"No more entries in query.\" ) end break end end ProfileStore:WipeProfileAsync() ProfileStore : WipeProfileAsync ( profile_key ) --> is_wipe_successful [bool] -- profile_key [string] -- DataStore key Use :WipeProfileAsync() to erase user data when complying with right of erasure requests. In live Roblox servers :WipeProfileAsync() must be used on profiles created through ProfileStore.Mock after Profile:Release() and it's known that the Profile will no longer be loaded again. ProfileStore.Mock local ProfileTemplate = {} local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) local LiveProfile = GameProfileStore : LoadProfileAsync ( \"profile_key\" , \"ForceLoad\" ) local MockProfile = GameProfileStore . Mock : LoadProfileAsync ( \"profile_key\" , \"ForceLoad\" ) print ( LiveProfile ~= MockProfile ) --> true -- When done using mock profile on live servers: (Prevent memory leak) MockProfile : Release () GameProfileStore . Mock : WipeProfileAsync ( \"profile_key\" ) -- You don't really have to wipe mock profiles in studio testing ProfileStore.Mock is a reflection of methods available in the ProfileStore object with the exception of profile operations being performed on profiles stored on a separate, detached \"fake\" DataStore that will be forgotten when the game session ends. You may load profiles of the same key from ProfileStore and ProfileStore.Mock in parallel - these will be two different profiles because the regular and mock versions of the same ProfileStore are completely isolated from each other. ProfileStore.Mock is useful for customizing your testing environment in cases when you want to enable Roblox API services in studio, but don't want ProfileService to save to live keys: local RunService = game : GetService ( \"RunService\" ) local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) if RunService : IsStudio () == true then GameProfileStore = GameProfileStore . Mock end A few more things: Even when Roblox API services are disabled, ProfileStore and ProfileStore.Mock will store profiles in separate stores. It's better to think of ProfileStore and ProfileStore.Mock as two different ProfileStore objects unrelated to each other in any way. It's possible to create a project that utilizes both live and mock profiles on live servers! Profile Profile.Data Profile . Data [ table ] -- Non-strict reference - developer can set this value to a new table reference Profile.Data is the primary variable of a Profile object. The developer is free to read and write from the table while it is automatically saved to the DataStore . Profile.Data will no longer be saved after being released remotely or locally via Profile:Release() . Profile.MetaData Profile . MetaData [ table ] ( Read - only ) -- Data about the profile itself Profile . MetaData . ProfileCreateTime [ number ] ( Read - only ) -- os.time() timestamp of profile creation Profile . MetaData . SessionLoadCount [ number ] ( Read - only ) -- Amount of times the profile was loaded Profile . MetaData . ActiveSession [ table ] or nil ( Read - only ) -- {place_id, game_job_id} or nil -- Set to a session link if a Roblox server is currently the -- owner of this profile; nil if released Profile . MetaData . MetaTags [ table ] ( Writable ) -- {[\"tag_name\"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data Profile . MetaData . MetaTagsLatest [ table ] ( Read - only ) -- the most recent version of MetaData.MetaTags which has -- been saved to the DataStore during the last auto-save -- or Profile:Save() call Profile.MetaData is a table containing data about the profile itself. Profile.MetaData.MetaTags is saved on the same DataStore key together with Profile.Data . Profile.MetaTagsUpdated Profile . MetaTagsUpdated [ ScriptSignal ] ( meta_tags_latest ) This signal fires after every auto-save, after Profile.MetaData.MetaTagsLatest has been updated with the version that's guaranteed to be saved. MetaTagsUpdated will fire regardless of whether MetaTagsLatest changed after update. MetaTagsUpdated will also fire after the Profile is saved for the last time and released . Remember that changes to Profile.Data will not be saved after release - Profile:IsActive() will return false if the profile is released. MetaTagsUpdated example use can be found in the Developer Products example code . Profile.RobloxMetaData Profile . RobloxMetaData [ table ] -- Non-strict reference - developer can set this value to a new table reference Be cautious of very harsh limits for maximum Roblox Metadata size - As of writing this, total table content size cannot exceed 300 characters. Table that gets saved as Metadata (Official documentation) of a DataStore key belonging to the profile. The way this table is saved is equivalent to using DataStoreSetOptions:SetMetaData(Profile.RobloxMetaData) and passing the DataStoreSetOptions object to a :SetAsync() call, except changes will truly get saved on the next auto-update cycle or when the profile is released. The periodic saving and saving upon releasing behaviour is identical to that of Profile.Data - After the profile is released further changes to this value will not be saved. Example: local profile -- A profile object you loaded -- Mimicking the Roblox hub example: profile . RobloxMetaData = {[ \"ExperienceElement\" ] = \"Fire\" } -- You can read from it and write to it at will: print ( profile . RobloxMetaData . ExperienceElement ) profile . RobloxMetaData . ExperienceElement = nil profile . RobloxMetaData . UserCategory = \"Casual\" -- I think setting it to a whole table at profile load would -- be more safe considering the size limit for meta data -- is pretty tight: profile . RobloxMetaData = { UserCategory = \"Casual\" , FavoriteColor = { 1 , 0 , 0 }, } Profile.UserIds Profile . UserIds [ table ] -- (READ-ONLY) -- {user_id [number], ...} User ids associated with this profile. Entries must be added with Profile:AddUserId() and removed with Profile:RemoveUserId() . Profile.KeyInfo Profile . KeyInfo [ DataStoreKeyInfo ] The DataStoreKeyInfo (Official documentation) instance related to this profile Profile.KeyInfoUpdated Profile . KeyInfoUpdated [ ScriptSignal ] ( key_info [ DataStoreKeyInfo ]) A signal that gets triggered every time Profile.KeyInfo is updated with a new DataStoreKeyInfo instance reference after every auto-save or profile release. Profile.GlobalUpdates Profile . GlobalUpdates [ GlobalUpdates ] This is the GlobalUpdates object tied to this specific Profile . It exposes GlobalUpdates methods for update processing. (See Global Updates for more info) Profile:IsActive() Profile : IsActive () --> [bool] Returns true while the profile is session-locked and saving of changes to Profile.Data is guaranteed. Profile:GetMetaTag() Profile : GetMetaTag ( tag_name ) --> value -- tag_name [string] Equivalent of Profile.MetaData.MetaTags[tag_name] . See Profile:SetMetaTag() for more info. Profile:Reconcile() Profile : Reconcile () --> nil Fills in missing variables inside Profile.Data from profile_template table that was provided when calling ProfileService.GetProfileStore() . It's often necessary to use :Reconcile() if you're applying changes to your profile_template over the course of your game's development after release. The right time to call this method can be seen in the basic usage example . The following function is used in the reconciliation process: local function ReconcileTable ( target , template ) for k , v in pairs ( template ) do if type ( k ) == \"string\" then -- Only string keys will be reconciled if target [ k ] == nil then if type ( v ) == \"table\" then target [ k ] = DeepCopyTable ( v ) else target [ k ] = v end elseif type ( target [ k ]) == \"table\" and type ( v ) == \"table\" then ReconcileTable ( target [ k ], v ) end end end end Profile:ListenToRelease() Profile : ListenToRelease ( listener ) --> [ScriptConnection] (place_id / nil, game_job_id / nil) -- listener [function] (place_id / nil, game_job_id / nil) Listener functions subscribed to Profile:ListenToRelease() will be called when the profile is released remotely (Being \"ForceLoad\" 'ed on a remote server) or locally ( Profile:Release() ). In common practice, the profile will rarely be released before the player leaves the game so it's recommended to simply :Kick() the Player when this happens. Warning After Profile:ListenToRelease() is triggered, it is too late to change Profile.Data for the final time. As long as the profile is active ( Profile:IsActive() == true ), you should store all profile related data immediately after it becomes available. An item trading operation between two profiles must happen without any yielding after it is confirmed that both profiles are active. Profile:Release() Profile : Release () Removes the session lock for this profile for this Roblox server. Call this method after you're done working with the Profile object. Profile data will be immediately saved for the last time. Profile:ListenToHopReady() Profile : ListenToHopReady ( listener ) --> [ScriptConnection] () -- listener [function] () In many cases ProfileService will be fast enough when loading and releasing profiles as the player teleports between places belonging to the same universe / game. However, if you're experiencing noticable delays when loading profiles after a universe teleport, you should try implementing :ListenToHopReady() . A listener passed to :ListenToHopReady() will be executed after the releasing UpdateAsync call finishes. :ListenToHopReady() will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a profile is released next to an auto-update interval (regular usage scenario - rapid loading / releasing of the same profile key may yield different results). Example use: local TeleportService = game : GetService ( \"TeleportService\" ) local profile , player , place_id profile : Release () profile : ListenToHopReady ( function () TeleportService : TeleportAsync ( place_id , { player }) end ) In short, Profile:ListenToRelease() and Profile:ListenToHopReady() will both execute the listener function after release, but Profile:ListenToHopReady() will additionally wait until the session lock is removed from the Profile . Profile:AddUserId() Profile : AddUserId ( user_id ) -- user_id [number] Associates a UserId with the profile. Multiple users can be associated with a single profile by calling this method for each individual UserId . The primary use of this method is to comply with GDPR (The right to erasure). More information in official documentation . The right time to call this method can be seen in the basic usage example . Profile:RemoveUserId() Profile : RemoveUserId ( user_id ) -- user_id [number] Unassociates UserId with the profile if it was initially associated. Profile:Identify() Profile : Identify () --> [string] -- Example return: \"[Store:\"GameData\";Scope:\"Live\";Key:\"Player_2312310\"]\" Returns a string containing DataStore name, scope and key; Used for debugging; Profile:SetMetaTag() Profile : SetMetaTag ( tag_name , value ) -- tag_name [string] -- value -- Any value supported by DataStore Equivalent of Profile.MetaData.MetaTags[tag_name] = value . Use for tagging your profile with information about itself such as: profile:SetMetaTag(\"DataVersion\", 1) to let your game code know whether Profile.Data needs to be converted after massive changes to the game. Anything set through profile:SetMetaTag(tag_name, value) will be available through Profile.MetaData.MetaTagsLatest[tag_name] after an auto-save or a :Save() call - Profile.MetaData.MetaTagsLatest is a version of Profile.MetaData.MetaTags that has been successfully saved to the DataStore. Notice You can use Profile.MetaData.MetaTagsLatest for product purchase confirmation (By storing receiptInfo.PurchaseId values inside Profile.MetaData.MetaTags and waiting for them to appear in Profile.MetaData.MetaTagsLatest ). Don't forget to clear really old PurchaseId 's to stay under DataStore limits. Profile:Save() Profile : Save () -- Call to quickly progress GlobalUpdates -- state or to speed up save validation processes -- (Does not yield) Call Profile:Save() to quickly progress GlobalUpdates state or to speed up the propagation of Profile.MetaData.MetaTags changes to Profile.MetaData.MetaTagsLatest . Profile:Save() should not be called for saving Profile.Data or Profile.MetaData.MetaTags - this is already done for you automatically. Warning Calling Profile:Save() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. Profile:ClearGlobalUpdates() Profile : ClearGlobalUpdates () Only works for profiles loaded through :ViewProfileAsync() or :ProfileVersionQuery() Clears all global update data (active or locked) for a profile payload. It may be desirable to clear potential \"residue\" global updates (e.g. pending gifts) which were existing in a snapshot which is being used to recover player data through :ProfileVersionQuery() . Profile:OverwriteAsync() Profile : OverwriteAsync () Only works for profiles loaded through :ViewProfileAsync() or :ProfileVersionQuery() Only use for rollback payloads (Setting latest version to a copy of a previous version)! Using this method for editing latest player data when the player is in-game can lead to several minutes of lost progress - it should be replaced by :LoadProfileAsync() which will wait for the next live profile auto-save if the player is in-game, allowing the remote server to release the profile and save latest data. Pushes the Profile payload to the DataStore (saves the profile) and releases the session lock for the profile. Global Updates Global updates is a powerful feature of ProfileService, used for sending information to a desired player profile across servers, within the server or to a player profile that is not currently active in any Roblox server (Kind of like MessagingService , but slower and doesn't require the recipient to be active). The primary intended use of global updates is to support sending gifts among players, or giving items to players through a custom admin tool. The benefit of using global updates is it's API simplicity (This is as simple as it gets, sorry \ud83d\ude02) and the fact that global updates are pulled from the DataStore whenever the profile is auto-saved at no additional expense of more DataStore calls! Global updates can be Active , Locked and Cleared : Whenever a global update is created, it will be Active by default Active updates can be changed or cleared within a :GlobalUpdateProfileAsync() call Normally, when the profile is active on a Roblox server, you should always progress all Active updates to the Locked state Locked updates can no longer be changed or cleared within a :GlobalUpdateProfileAsync() call Locked updates are ready to be processed (e.g., add gift to player inventory) and imediately Locked by calling :LockActiveUpdate(update_id) Cleared updates will immediately disappear from the profile forever Always available GlobalUpdates:GetActiveUpdates() GlobalUpdates : GetActiveUpdates () --> [table] { {update_id, update_data}, ...} Should be used immediately after a Profile is loaded to scan and progress any pending Active updates to Locked state: for _ , update in ipairs ( profile . GlobalUpdates : GetActiveUpdates ()) do profile . GlobalUpdates : LockActiveUpdate ( update [ 1 ]) end GlobalUpdates:GetLockedUpdates() GlobalUpdates : GetLockedUpdates () --> [table] { {update_id, update_data}, ...} Should be used immediately after a Profile is loaded to scan and progress any pending Locked updates to Cleared state: for _ , update in ipairs ( profile . GlobalUpdates : GetLockedUpdates ()) do local update_id = update [ 1 ] local update_data = update [ 2 ] if update_data . Type == \"AdminGift\" and update_data . Item == \"Coins\" then profile . Data . Coins = profile . Data . Coins + update_data . Amount end profile . GlobalUpdates : ClearLockedUpdate ( update_id ) end Only when accessed from Profile.GlobalUpdates GlobalUpdates:ListenToNewActiveUpdate() GlobalUpdates : ListenToNewActiveUpdate ( listener ) --> [ScriptConnection] -- listener [function](update_id, update_data) In most games, you should progress all Active updates to Locked state: profile . GlobalUpdates : ListenToNewActiveUpdate ( function ( update_id , update_data ) profile . GlobalUpdates : LockActiveUpdate ( update_id ) end ) GlobalUpdates:ListenToNewLockedUpdate() GlobalUpdates : ListenToNewLockedUpdate ( listener ) --> [ScriptConnection] -- listener [function](update_id, update_data) -- Must always call GlobalUpdates:ClearLockedUpdate(update_id) -- after processing the locked update. When you get a Locked update via GlobalUpdates:ListenToNewLockedUpdate() , the update is ready to be proccessed and immediately locked: profile . GlobalUpdates : ListenToNewLockedUpdate ( function ( update_id , update_data ) if update_data . Type == \"AdminGift\" and update_data . Item == \"Coins\" then profile . Data . Coins = profile . Data . Coins + update_data . Amount end profile . GlobalUpdates : ClearLockedUpdate ( update_id ) end ) GlobalUpdates:LockActiveUpdate() GlobalUpdates : LockActiveUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Turns an Active update into a Locked update. Will invoke GlobalUpdates:ListenToNewLockedUpdate() after an auto-save (less than 30 seconds) or Profile:Save() . Warning Calling GlobalUpdates:LockActiveUpdate() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. ProfileService guarantees that the Profile will be active when GlobalUpdates:ListenToNewActiveUpdate() listeners are triggered. GlobalUpdates:ClearLockedUpdate() GlobalUpdates : ClearLockedUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Clears a Locked update completely from the profile. Warning Calling GlobalUpdates:ClearLockedUpdate() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. ProfileService guarantees that the Profile will be active when GlobalUpdates:ListenToNewLockedUpdate() listeners are triggered. Available inside update_handler during a ProfileStore:GlobalUpdateProfileAsync() call GlobalUpdates:AddActiveUpdate() GlobalUpdates : AddActiveUpdate ( update_data ) -- update_data [table] -- Your custom global update data Used to send a new Active update to the profile. GlobalUpdates:ChangeActiveUpdate() GlobalUpdates : ChangeActiveUpdate ( update_id , update_data ) -- update_id [number] -- Id of an existing global update -- update_data [table] -- New data that replaces previously set update_data Changing Active updates can be used for stacking player gifts, particularly when lots of players can be sending lots of gifts to a Youtube celebrity so the Profile would not exceed the DataStore data limit . GlobalUpdates:ClearActiveUpdate() GlobalUpdates : ClearActiveUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Removes an Active update from the profile completely.","title":"API"},{"location":"api/#profileservice","text":"","title":"ProfileService"},{"location":"api/#profileserviceservicelocked","text":"ProfileService . ServiceLocked [ bool ] Set to false when the Roblox server is shutting down. ProfileStore methods should not be called after this value is set to false","title":"ProfileService.ServiceLocked"},{"location":"api/#profileserviceissuesignal","text":"ProfileService . IssueSignal [ ScriptSignal ]( error_message [ string ], profile_store_name [ string ], profile_key [ string ]) Analytics endpoint for DataStore error logging. Example usage: ProfileService . IssueSignal : Connect ( function ( error_message , profile_store_name , profile_key ) pcall ( function () AnalyticsService : FireEvent ( \"ProfileServiceIssue\" , error_message , profile_store_name , profile_key ) end ) end )","title":"ProfileService.IssueSignal"},{"location":"api/#profileservicecorruptionsignal","text":"ProfileService . CorruptionSignal [ ScriptSignal ]( profile_store_name [ string ], profile_key [ string ]) Analytics endpoint for cases when a DataStore key returns a value that has all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a non table value","title":"ProfileService.CorruptionSignal"},{"location":"api/#profileservicecriticalstatesignal","text":"ProfileService . CriticalStateSignal [ ScriptSignal ] ( is_critical_state [ bool ]) Analytics endpoint for cases when DataStore is throwing too many errors and it's most likely affecting your game really really bad - this could be due to developer errors or due to Roblox server problems. Could be used to alert players about data store outages.","title":"ProfileService.CriticalStateSignal"},{"location":"api/#profileservicegetprofilestore","text":"ProfileService . GetProfileStore ( profile_store_index , profile_template ) --> [ProfileStore] -- profile_store_index [string] -- DataStore name -- OR -- profile_store_index [table]: -- Allows the developer to define more GlobalDataStore variables -- { -- Name = \"StoreName\", -- [string] -- DataStore name -- -- Optional arguments: -- Scope = \"StoreScope\", -- [string] -- DataStore scope -- } -- profile_template [table] -- Profile.Data will default to -- given table (deep-copy) when no data was saved previously ProfileStore objects expose methods for loading / viewing profiles and sending global updates. Equivalent of :GetDataStore() in Roblox DataStoreService API. Notice By default, profile_template is only copied for Profile.Data for new profiles. Changes made to profile_template can be applied to Profile.Data of previously saved profiles by calling Profile:Reconcile() . You can also create your own function to fill in the missing components in Profile.Data as soon as it is loaded or have nil exceptions in your personal :Get() and :Set() method libraries.","title":"ProfileService.GetProfileStore()"},{"location":"api/#profilestore","text":"","title":"ProfileStore"},{"location":"api/#profilestoreloadprofileasync","text":"ProfileStore : LoadProfileAsync ( profile_key , not_released_handler ) --> [Profile] or nil -- profile_key [string] -- DataStore key -- not_released_handler nil or []: -- Defaults to \"ForceLoad\" -- [string] \"ForceLoad\" -- Force loads profile on first call -- OR -- [string] \"Steal\" -- Steals the profile ignoring it's session lock -- OR -- [function] (place_id, game_job_id) --> [string] \"Repeat\", \"Cancel\", \"ForceLoad\" or \"Steal\" -- place_id [number] or nil -- game_job_id [string] or nil For basic usage, pass nil for the not_released_handler argument. not_released_handler as a function argument is called when the profile is session-locked by a remote Roblox server: local profile = ProfileStore : LoadProfileAsync ( \"Player_2312310\" , function ( place_id , game_job_id ) -- place_id and game_job_id identify the Roblox server that has -- this profile currently locked. In rare cases, if the server -- crashes, the profile will stay locked until ForceLoaded by -- a new session. return \"Repeat\" or \"Cancel\" or \"ForceLoad\" or \"Steal\" end ) not_released_handler must return one of the following values: return \"Repeat\" - ProfileService will repeat the profile loading proccess and may call the release handler again return \"Cancel\" - :LoadProfileAsync() will immediately return nil return \"ForceLoad\" - ProfileService will indefinitely attempt to load the profile. If the profile is session-locked by a remote Roblox server, it will either be released for that remote server or \"stolen\" (Stealing is necessary for remote servers that are not responding in time and for handling crashed server session-locks). return \"Steal\" - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying a session lock for this session. \"Steal\" can be used to clear dead session locks faster than \"ForceLoad\" assuming your code knows that the session lock is dead. Notice ProfileService saves profiles to live DataStore keys in Roblox Studio when Roblox API services are enabled . See ProfileStore.Mock if saving to live keys during testing is not desired. Warning :LoadProfileAsync() can return nil when another remote Roblox server attempts to load the profile at the same time. This case should be extremely rare and it would be recommended to :Kick() the player if :LoadProfileAsync() does not return a Profile object. Do not load a profile of the same key again before it is released Trying to load a profile that has already been session-locked on the same server will result in an error. You may, however, instantly load the profile again after releasing it with Profile:Release() .","title":"ProfileStore:LoadProfileAsync()"},{"location":"api/#profilestoreglobalupdateprofileasync","text":"ProfileStore : GlobalUpdateProfileAsync ( profile_key , update_handler ) --> [GlobalUpdates] or nil -- profile_key [string] -- DataStore key -- update_handler [function](global_updates) -- This function is -- called with a GlobalUpdates object Used to create and manage Active global updates for a specified Profile . Can be called on any Roblox server of your game. Updates should reach the recipient in less than 30 seconds, regardless of whether it was called on the same server the Profile is session-locked to. See Global Updates for more information. Example usage of :GlobalUpdateProfileAsync() : ProfileStore : GlobalUpdateProfileAsync ( \"Player_2312310\" , function ( global_updates ) global_updates : AddActiveUpdate ({ Type = \"AdminGift\" , Item = \"Coins\" , Amount = 1000 , }) end ) Notice :GlobalUpdateProfileAsync() will work for profiles that haven't been created (profiles are created when they're loaded using :LoadProfileAsync() for the first time) Yielding inside the update_handler function will throw an error Avoid rapid use of ProfileStore:GlobalUpdateProfileAsync() Excessive use of ProfileStore:GlobalUpdateProfileAsync() can lead to dead session locks and event lost Profile.Data (latter is mostly possible only if the Profile is loaded in the same session as :GlobalUpdateProfileAsync() is called). This is due to a queue system that executes every write request for the Profile every 7 seconds - if this queue grows larger than the BindToClose timeout (approx. 30 seconds), some requests in the queue can be lost after the game shuts down.","title":"ProfileStore:GlobalUpdateProfileAsync()"},{"location":"api/#profilestoreviewprofileasync","text":"ProfileStore : ViewProfileAsync ( profile_key , version ) --> [Profile] or nil -- profile_key [string] -- DataStore key -- version nil or [string] -- DataStore key version Passing version argument in mock mode (Or offline mode) will throw an error - Mock versioning is not supported Attempts to load the latest profile version (or a specified version via the version argument) from the DataStore without claiming a session lock. Returns nil if such version does not exist. Returned Profile will not auto-save and releasing won't do anything. Data in the returned Profile can be changed to create a payload which can be saved via Profile:OverwriteAsync() . :ViewProfileAsync() is the the prefered way of viewing player data without editing it.","title":"ProfileStore:ViewProfileAsync()"},{"location":"api/#profilestoreprofileversionquery","text":"ProfileStore : ProfileVersionQuery ( profile_key , sort_direction , min_date , max_date ) --> [ProfileVersionQuery] -- profile_key [string] -- sort_direction nil or [Enum.SortDirection] -- Defaults to \"Ascending\" -- min_date nil or [DateTime] or [number] (epoch time millis) -- max_date nil or [DateTime] or [number] (epoch time millis) Creates a profile version query using DataStore:ListVersionsAsync() (Official documentation) . Results are retrieved through ProfileVersionQuery:Next() . For additional help, check the versioning example in official Roblox documentation . Date definitions are easier with the DateTime (Official documentation) library. User defined day and time will have to be converted to Unix time (Wikipedia) while taking their timezone into account to expect the most precise results, though you can be rough and just set the date and time in the UTC timezone and expect a maximum margin of error of 24 hours for your query results. Examples of query arguments: Pass nil for sort_direction , min_date and max_date to find the oldest available version Pass Enum.SortDirection.Descending for sort_direction , nil for min_date and max_date to find the most recent version. Pass Enum.SortDirection.Descending for sort_direction , nil for min_date and DateTime defining a time before an event (e.g. two days earlier before your game unrightfully stole 1,000,000 rubies from a player) for max_date to find the most recent version of a Profile that existed before said event. Case example: \"I lost all of my rubies on August 14th!\" -- Get a ProfileStore object with the same arguments you passed to the -- ProfileStore that loads player Profiles. It can also just be -- the very same ProfileStore object: local ProfileStore = ProfileService . GetProfileStore ( store_name , template ) -- If you can't figure out the exact time and timezone the player lost rubies -- in on the day of August 14th, then your best bet is to try querying -- UTC August 13th. If the first entry still doesn't have the rubies - -- try a new query of UTC August 12th and etc. local max_date = DateTime . fromUniversalTime ( 2021 , 08 , 13 ) -- UTC August 13th, 2021 local query = ProfileStore : ProfileVersionQuery ( \"Player_2312310\" , -- The same profile key that gets passed to :LoadProfileAsync() Enum . SortDirection . Descending , nil , max_date ) -- Get the first result in the query: local profile = query : NextAsync () if profile ~= nil then profile : ClearGlobalUpdates () profile : OverwriteAsync () -- This method does the actual rolling back; -- Don't call this method until you're sure about setting the latest -- version to a copy of the previous one print ( \"Rollback success!\" ) print ( profile . Data ) -- You'll be able to surf table contents if -- you're runing this code in studio with access to API services -- enabled and have expressive output enabled; If the printed -- data doesn't have the rubies, you'll want to change your -- query parameters. else print ( \"No version to rollback to\" ) end Case example: Studying data mutation over time -- You have ProfileService working in your game. You join -- the game with your own account and go to https://www.unixtimestamp.com -- and save the current UNIX timestamp resembling present time. -- You can then make the game alter your data by giving you -- currency, items, experience, etc. local ProfileStore = ProfileService . GetProfileStore ( store_name , template ) -- UNIX timestamp you saved: local min_date = DateTime . fromUnixTimestamp ( 1628952101 ) local print_minutes = 5 -- Print the next 5 minutes of history local query = ProfileStore : ProfileVersionQuery ( \"Player_2312310\" , Enum . SortDirection . Ascending , min_date ) -- You can now attempt to print out every snapshot of your data saved -- at an average periodic interval of 30 seconds (ProfileService auto-save) -- starting from the time you took the UNIX timestamp! local finish_update_time = min_date . UnixTimestampMillis + ( print_minutes * 60000 ) print ( \"Fetching \" , print_minutes , \"minutes of saves:\" ) local entry_count = 0 while true do entry_count += 1 local profile = query : NextAsync () if profile ~= nil then if profile . KeyInfo . UpdatedTime > finish_update_time then if entry_count == 1 then print ( \"No entries found in set time period. (Start timestamp too early)\" ) else print ( \"Time period finished.\" ) end break end print ( \"Entry\" , entry_count , \"-\" , DateTime . fromUnixTimestampMillis ( profile . KeyInfo . UpdatedTime ): ToIsoDate () ) print ( profile . Data ) -- Printing table for studio expressive output else if entry_count == 1 then print ( \"No entries found in set time period. (Start timestamp too late)\" ) else print ( \"No more entries in query.\" ) end break end end","title":"ProfileStore:ProfileVersionQuery()"},{"location":"api/#profilestorewipeprofileasync","text":"ProfileStore : WipeProfileAsync ( profile_key ) --> is_wipe_successful [bool] -- profile_key [string] -- DataStore key Use :WipeProfileAsync() to erase user data when complying with right of erasure requests. In live Roblox servers :WipeProfileAsync() must be used on profiles created through ProfileStore.Mock after Profile:Release() and it's known that the Profile will no longer be loaded again.","title":"ProfileStore:WipeProfileAsync()"},{"location":"api/#profilestoremock","text":"local ProfileTemplate = {} local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) local LiveProfile = GameProfileStore : LoadProfileAsync ( \"profile_key\" , \"ForceLoad\" ) local MockProfile = GameProfileStore . Mock : LoadProfileAsync ( \"profile_key\" , \"ForceLoad\" ) print ( LiveProfile ~= MockProfile ) --> true -- When done using mock profile on live servers: (Prevent memory leak) MockProfile : Release () GameProfileStore . Mock : WipeProfileAsync ( \"profile_key\" ) -- You don't really have to wipe mock profiles in studio testing ProfileStore.Mock is a reflection of methods available in the ProfileStore object with the exception of profile operations being performed on profiles stored on a separate, detached \"fake\" DataStore that will be forgotten when the game session ends. You may load profiles of the same key from ProfileStore and ProfileStore.Mock in parallel - these will be two different profiles because the regular and mock versions of the same ProfileStore are completely isolated from each other. ProfileStore.Mock is useful for customizing your testing environment in cases when you want to enable Roblox API services in studio, but don't want ProfileService to save to live keys: local RunService = game : GetService ( \"RunService\" ) local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) if RunService : IsStudio () == true then GameProfileStore = GameProfileStore . Mock end A few more things: Even when Roblox API services are disabled, ProfileStore and ProfileStore.Mock will store profiles in separate stores. It's better to think of ProfileStore and ProfileStore.Mock as two different ProfileStore objects unrelated to each other in any way. It's possible to create a project that utilizes both live and mock profiles on live servers!","title":"ProfileStore.Mock"},{"location":"api/#profile","text":"","title":"Profile"},{"location":"api/#profiledata","text":"Profile . Data [ table ] -- Non-strict reference - developer can set this value to a new table reference Profile.Data is the primary variable of a Profile object. The developer is free to read and write from the table while it is automatically saved to the DataStore . Profile.Data will no longer be saved after being released remotely or locally via Profile:Release() .","title":"Profile.Data"},{"location":"api/#profilemetadata","text":"Profile . MetaData [ table ] ( Read - only ) -- Data about the profile itself Profile . MetaData . ProfileCreateTime [ number ] ( Read - only ) -- os.time() timestamp of profile creation Profile . MetaData . SessionLoadCount [ number ] ( Read - only ) -- Amount of times the profile was loaded Profile . MetaData . ActiveSession [ table ] or nil ( Read - only ) -- {place_id, game_job_id} or nil -- Set to a session link if a Roblox server is currently the -- owner of this profile; nil if released Profile . MetaData . MetaTags [ table ] ( Writable ) -- {[\"tag_name\"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data Profile . MetaData . MetaTagsLatest [ table ] ( Read - only ) -- the most recent version of MetaData.MetaTags which has -- been saved to the DataStore during the last auto-save -- or Profile:Save() call Profile.MetaData is a table containing data about the profile itself. Profile.MetaData.MetaTags is saved on the same DataStore key together with Profile.Data .","title":"Profile.MetaData"},{"location":"api/#profilemetatagsupdated","text":"Profile . MetaTagsUpdated [ ScriptSignal ] ( meta_tags_latest ) This signal fires after every auto-save, after Profile.MetaData.MetaTagsLatest has been updated with the version that's guaranteed to be saved. MetaTagsUpdated will fire regardless of whether MetaTagsLatest changed after update. MetaTagsUpdated will also fire after the Profile is saved for the last time and released . Remember that changes to Profile.Data will not be saved after release - Profile:IsActive() will return false if the profile is released. MetaTagsUpdated example use can be found in the Developer Products example code .","title":"Profile.MetaTagsUpdated"},{"location":"api/#profilerobloxmetadata","text":"Profile . RobloxMetaData [ table ] -- Non-strict reference - developer can set this value to a new table reference Be cautious of very harsh limits for maximum Roblox Metadata size - As of writing this, total table content size cannot exceed 300 characters. Table that gets saved as Metadata (Official documentation) of a DataStore key belonging to the profile. The way this table is saved is equivalent to using DataStoreSetOptions:SetMetaData(Profile.RobloxMetaData) and passing the DataStoreSetOptions object to a :SetAsync() call, except changes will truly get saved on the next auto-update cycle or when the profile is released. The periodic saving and saving upon releasing behaviour is identical to that of Profile.Data - After the profile is released further changes to this value will not be saved. Example: local profile -- A profile object you loaded -- Mimicking the Roblox hub example: profile . RobloxMetaData = {[ \"ExperienceElement\" ] = \"Fire\" } -- You can read from it and write to it at will: print ( profile . RobloxMetaData . ExperienceElement ) profile . RobloxMetaData . ExperienceElement = nil profile . RobloxMetaData . UserCategory = \"Casual\" -- I think setting it to a whole table at profile load would -- be more safe considering the size limit for meta data -- is pretty tight: profile . RobloxMetaData = { UserCategory = \"Casual\" , FavoriteColor = { 1 , 0 , 0 }, }","title":"Profile.RobloxMetaData"},{"location":"api/#profileuserids","text":"Profile . UserIds [ table ] -- (READ-ONLY) -- {user_id [number], ...} User ids associated with this profile. Entries must be added with Profile:AddUserId() and removed with Profile:RemoveUserId() .","title":"Profile.UserIds"},{"location":"api/#profilekeyinfo","text":"Profile . KeyInfo [ DataStoreKeyInfo ] The DataStoreKeyInfo (Official documentation) instance related to this profile","title":"Profile.KeyInfo"},{"location":"api/#profilekeyinfoupdated","text":"Profile . KeyInfoUpdated [ ScriptSignal ] ( key_info [ DataStoreKeyInfo ]) A signal that gets triggered every time Profile.KeyInfo is updated with a new DataStoreKeyInfo instance reference after every auto-save or profile release.","title":"Profile.KeyInfoUpdated"},{"location":"api/#profileglobalupdates","text":"Profile . GlobalUpdates [ GlobalUpdates ] This is the GlobalUpdates object tied to this specific Profile . It exposes GlobalUpdates methods for update processing. (See Global Updates for more info)","title":"Profile.GlobalUpdates"},{"location":"api/#profileisactive","text":"Profile : IsActive () --> [bool] Returns true while the profile is session-locked and saving of changes to Profile.Data is guaranteed.","title":"Profile:IsActive()"},{"location":"api/#profilegetmetatag","text":"Profile : GetMetaTag ( tag_name ) --> value -- tag_name [string] Equivalent of Profile.MetaData.MetaTags[tag_name] . See Profile:SetMetaTag() for more info.","title":"Profile:GetMetaTag()"},{"location":"api/#profilereconcile","text":"Profile : Reconcile () --> nil Fills in missing variables inside Profile.Data from profile_template table that was provided when calling ProfileService.GetProfileStore() . It's often necessary to use :Reconcile() if you're applying changes to your profile_template over the course of your game's development after release. The right time to call this method can be seen in the basic usage example . The following function is used in the reconciliation process: local function ReconcileTable ( target , template ) for k , v in pairs ( template ) do if type ( k ) == \"string\" then -- Only string keys will be reconciled if target [ k ] == nil then if type ( v ) == \"table\" then target [ k ] = DeepCopyTable ( v ) else target [ k ] = v end elseif type ( target [ k ]) == \"table\" and type ( v ) == \"table\" then ReconcileTable ( target [ k ], v ) end end end end","title":"Profile:Reconcile()"},{"location":"api/#profilelistentorelease","text":"Profile : ListenToRelease ( listener ) --> [ScriptConnection] (place_id / nil, game_job_id / nil) -- listener [function] (place_id / nil, game_job_id / nil) Listener functions subscribed to Profile:ListenToRelease() will be called when the profile is released remotely (Being \"ForceLoad\" 'ed on a remote server) or locally ( Profile:Release() ). In common practice, the profile will rarely be released before the player leaves the game so it's recommended to simply :Kick() the Player when this happens. Warning After Profile:ListenToRelease() is triggered, it is too late to change Profile.Data for the final time. As long as the profile is active ( Profile:IsActive() == true ), you should store all profile related data immediately after it becomes available. An item trading operation between two profiles must happen without any yielding after it is confirmed that both profiles are active.","title":"Profile:ListenToRelease()"},{"location":"api/#profilerelease","text":"Profile : Release () Removes the session lock for this profile for this Roblox server. Call this method after you're done working with the Profile object. Profile data will be immediately saved for the last time.","title":"Profile:Release()"},{"location":"api/#profilelistentohopready","text":"Profile : ListenToHopReady ( listener ) --> [ScriptConnection] () -- listener [function] () In many cases ProfileService will be fast enough when loading and releasing profiles as the player teleports between places belonging to the same universe / game. However, if you're experiencing noticable delays when loading profiles after a universe teleport, you should try implementing :ListenToHopReady() . A listener passed to :ListenToHopReady() will be executed after the releasing UpdateAsync call finishes. :ListenToHopReady() will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a profile is released next to an auto-update interval (regular usage scenario - rapid loading / releasing of the same profile key may yield different results). Example use: local TeleportService = game : GetService ( \"TeleportService\" ) local profile , player , place_id profile : Release () profile : ListenToHopReady ( function () TeleportService : TeleportAsync ( place_id , { player }) end ) In short, Profile:ListenToRelease() and Profile:ListenToHopReady() will both execute the listener function after release, but Profile:ListenToHopReady() will additionally wait until the session lock is removed from the Profile .","title":"Profile:ListenToHopReady()"},{"location":"api/#profileadduserid","text":"Profile : AddUserId ( user_id ) -- user_id [number] Associates a UserId with the profile. Multiple users can be associated with a single profile by calling this method for each individual UserId . The primary use of this method is to comply with GDPR (The right to erasure). More information in official documentation . The right time to call this method can be seen in the basic usage example .","title":"Profile:AddUserId()"},{"location":"api/#profileremoveuserid","text":"Profile : RemoveUserId ( user_id ) -- user_id [number] Unassociates UserId with the profile if it was initially associated.","title":"Profile:RemoveUserId()"},{"location":"api/#profileidentify","text":"Profile : Identify () --> [string] -- Example return: \"[Store:\"GameData\";Scope:\"Live\";Key:\"Player_2312310\"]\" Returns a string containing DataStore name, scope and key; Used for debugging;","title":"Profile:Identify()"},{"location":"api/#profilesetmetatag","text":"Profile : SetMetaTag ( tag_name , value ) -- tag_name [string] -- value -- Any value supported by DataStore Equivalent of Profile.MetaData.MetaTags[tag_name] = value . Use for tagging your profile with information about itself such as: profile:SetMetaTag(\"DataVersion\", 1) to let your game code know whether Profile.Data needs to be converted after massive changes to the game. Anything set through profile:SetMetaTag(tag_name, value) will be available through Profile.MetaData.MetaTagsLatest[tag_name] after an auto-save or a :Save() call - Profile.MetaData.MetaTagsLatest is a version of Profile.MetaData.MetaTags that has been successfully saved to the DataStore. Notice You can use Profile.MetaData.MetaTagsLatest for product purchase confirmation (By storing receiptInfo.PurchaseId values inside Profile.MetaData.MetaTags and waiting for them to appear in Profile.MetaData.MetaTagsLatest ). Don't forget to clear really old PurchaseId 's to stay under DataStore limits.","title":"Profile:SetMetaTag()"},{"location":"api/#profilesave","text":"Profile : Save () -- Call to quickly progress GlobalUpdates -- state or to speed up save validation processes -- (Does not yield) Call Profile:Save() to quickly progress GlobalUpdates state or to speed up the propagation of Profile.MetaData.MetaTags changes to Profile.MetaData.MetaTagsLatest . Profile:Save() should not be called for saving Profile.Data or Profile.MetaData.MetaTags - this is already done for you automatically. Warning Calling Profile:Save() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method.","title":"Profile:Save()"},{"location":"api/#profileclearglobalupdates","text":"Profile : ClearGlobalUpdates () Only works for profiles loaded through :ViewProfileAsync() or :ProfileVersionQuery() Clears all global update data (active or locked) for a profile payload. It may be desirable to clear potential \"residue\" global updates (e.g. pending gifts) which were existing in a snapshot which is being used to recover player data through :ProfileVersionQuery() .","title":"Profile:ClearGlobalUpdates()"},{"location":"api/#profileoverwriteasync","text":"Profile : OverwriteAsync () Only works for profiles loaded through :ViewProfileAsync() or :ProfileVersionQuery() Only use for rollback payloads (Setting latest version to a copy of a previous version)! Using this method for editing latest player data when the player is in-game can lead to several minutes of lost progress - it should be replaced by :LoadProfileAsync() which will wait for the next live profile auto-save if the player is in-game, allowing the remote server to release the profile and save latest data. Pushes the Profile payload to the DataStore (saves the profile) and releases the session lock for the profile.","title":"Profile:OverwriteAsync()"},{"location":"api/#global-updates","text":"Global updates is a powerful feature of ProfileService, used for sending information to a desired player profile across servers, within the server or to a player profile that is not currently active in any Roblox server (Kind of like MessagingService , but slower and doesn't require the recipient to be active). The primary intended use of global updates is to support sending gifts among players, or giving items to players through a custom admin tool. The benefit of using global updates is it's API simplicity (This is as simple as it gets, sorry \ud83d\ude02) and the fact that global updates are pulled from the DataStore whenever the profile is auto-saved at no additional expense of more DataStore calls! Global updates can be Active , Locked and Cleared : Whenever a global update is created, it will be Active by default Active updates can be changed or cleared within a :GlobalUpdateProfileAsync() call Normally, when the profile is active on a Roblox server, you should always progress all Active updates to the Locked state Locked updates can no longer be changed or cleared within a :GlobalUpdateProfileAsync() call Locked updates are ready to be processed (e.g., add gift to player inventory) and imediately Locked by calling :LockActiveUpdate(update_id) Cleared updates will immediately disappear from the profile forever","title":"Global Updates"},{"location":"api/#always-available","text":"","title":"Always available"},{"location":"api/#globalupdatesgetactiveupdates","text":"GlobalUpdates : GetActiveUpdates () --> [table] { {update_id, update_data}, ...} Should be used immediately after a Profile is loaded to scan and progress any pending Active updates to Locked state: for _ , update in ipairs ( profile . GlobalUpdates : GetActiveUpdates ()) do profile . GlobalUpdates : LockActiveUpdate ( update [ 1 ]) end","title":"GlobalUpdates:GetActiveUpdates()"},{"location":"api/#globalupdatesgetlockedupdates","text":"GlobalUpdates : GetLockedUpdates () --> [table] { {update_id, update_data}, ...} Should be used immediately after a Profile is loaded to scan and progress any pending Locked updates to Cleared state: for _ , update in ipairs ( profile . GlobalUpdates : GetLockedUpdates ()) do local update_id = update [ 1 ] local update_data = update [ 2 ] if update_data . Type == \"AdminGift\" and update_data . Item == \"Coins\" then profile . Data . Coins = profile . Data . Coins + update_data . Amount end profile . GlobalUpdates : ClearLockedUpdate ( update_id ) end","title":"GlobalUpdates:GetLockedUpdates()"},{"location":"api/#only-when-accessed-from-profileglobalupdates","text":"","title":"Only when accessed from Profile.GlobalUpdates"},{"location":"api/#globalupdateslistentonewactiveupdate","text":"GlobalUpdates : ListenToNewActiveUpdate ( listener ) --> [ScriptConnection] -- listener [function](update_id, update_data) In most games, you should progress all Active updates to Locked state: profile . GlobalUpdates : ListenToNewActiveUpdate ( function ( update_id , update_data ) profile . GlobalUpdates : LockActiveUpdate ( update_id ) end )","title":"GlobalUpdates:ListenToNewActiveUpdate()"},{"location":"api/#globalupdateslistentonewlockedupdate","text":"GlobalUpdates : ListenToNewLockedUpdate ( listener ) --> [ScriptConnection] -- listener [function](update_id, update_data) -- Must always call GlobalUpdates:ClearLockedUpdate(update_id) -- after processing the locked update. When you get a Locked update via GlobalUpdates:ListenToNewLockedUpdate() , the update is ready to be proccessed and immediately locked: profile . GlobalUpdates : ListenToNewLockedUpdate ( function ( update_id , update_data ) if update_data . Type == \"AdminGift\" and update_data . Item == \"Coins\" then profile . Data . Coins = profile . Data . Coins + update_data . Amount end profile . GlobalUpdates : ClearLockedUpdate ( update_id ) end )","title":"GlobalUpdates:ListenToNewLockedUpdate()"},{"location":"api/#globalupdateslockactiveupdate","text":"GlobalUpdates : LockActiveUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Turns an Active update into a Locked update. Will invoke GlobalUpdates:ListenToNewLockedUpdate() after an auto-save (less than 30 seconds) or Profile:Save() . Warning Calling GlobalUpdates:LockActiveUpdate() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. ProfileService guarantees that the Profile will be active when GlobalUpdates:ListenToNewActiveUpdate() listeners are triggered.","title":"GlobalUpdates:LockActiveUpdate()"},{"location":"api/#globalupdatesclearlockedupdate","text":"GlobalUpdates : ClearLockedUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Clears a Locked update completely from the profile. Warning Calling GlobalUpdates:ClearLockedUpdate() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. ProfileService guarantees that the Profile will be active when GlobalUpdates:ListenToNewLockedUpdate() listeners are triggered.","title":"GlobalUpdates:ClearLockedUpdate()"},{"location":"api/#available-inside-update_handler-during-a-profilestoreglobalupdateprofileasync-call","text":"","title":"Available inside update_handler during a ProfileStore:GlobalUpdateProfileAsync() call"},{"location":"api/#globalupdatesaddactiveupdate","text":"GlobalUpdates : AddActiveUpdate ( update_data ) -- update_data [table] -- Your custom global update data Used to send a new Active update to the profile.","title":"GlobalUpdates:AddActiveUpdate()"},{"location":"api/#globalupdateschangeactiveupdate","text":"GlobalUpdates : ChangeActiveUpdate ( update_id , update_data ) -- update_id [number] -- Id of an existing global update -- update_data [table] -- New data that replaces previously set update_data Changing Active updates can be used for stacking player gifts, particularly when lots of players can be sending lots of gifts to a Youtube celebrity so the Profile would not exceed the DataStore data limit .","title":"GlobalUpdates:ChangeActiveUpdate()"},{"location":"api/#globalupdatesclearactiveupdate","text":"GlobalUpdates : ClearActiveUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Removes an Active update from the profile completely.","title":"GlobalUpdates:ClearActiveUpdate()"},{"location":"troubleshooting/","text":"Whether you're still writing your game code or already ran into a problem while using ProfileService, this page is a valuable resource for avoiding several crucial mistakes. Problems in Roblox studio testing By default, data saved with ProfileService in Roblox Studio will not persist. This can be changed by enabling studio access to API services . Warning When studio access to API services is enabled, ProfileService will write to live DataStore keys of the game you're editing (unless ProfileStore.Mock is used) and you might accidentally make unwanted changes to your game's saved data. For more info, check the official documentation . Saving data which Roblox cannot serialize I've made the decision to opt-out Profile.Data and Profile.MetaData.MetaTags automatic checking for unserializable data types for efficiency reasons. Consequently, you must be aware of what you MUST AVOID writing inside Profile.Data or Profile.MetaData.MetaTags , directly and inside any nested tables: NaN values - you can check if a number is NaN by comparing it with itself - print(NaN == NaN) --> false (e.g., Profile.Data = {Experience = 0/0} ). NaN values are a result of division by zero and edge cases of some math operations ( math.acos(2) is -NaN ). Table keys that are neither strings nor numbers (e.g., Profile.Data[game.Workspace] = true ). Mixing string keys with number keys within the same table (e.g., Profile.Data = {Coins = 100, [5] = \"yes\"} ). Storing tables with non-sequential indexes (e.g., Profile.Data = {[1] = \"Apple\", [2] = \"Banana\", [3546] = \"Peanut\"} ). If you really have to store non-sequential numbers as indexes, you will have to turn those numbers into string indexes: Profile.Data.Friends[tostring(user_id)] = {GoodFriend = true} . Storing cyclic tables (e.g., Profile.Data = {Self = Profile.Data} ). Storing any userdata including Instance , Vector3 , CFrame , Udim2 , etc. Check whether your value is a userdata by running print(type(value) == \"userdata\") (e.g., Profile.Data = {LastPosition = Vector3.new(0, 0, 0)} ) - For storage, you will have to manually convert your userdata to tables, numbers and strings for storage (e.g., Profile.Data = {LastPosition = {position.X, position.Y, position.Z} } ). This is a limitation of the DataStore API which ProfileService is based on. Warning Failure to prevent these data types may result in silent data loss, silent errors, fatal errors and overall failure to save data. Profiles take over 7 seconds to load Notice Due to technical limitations, it's expected that at least 5% of the time, when the player hops servers rapidly, the profile can take up to 7 seconds to load (Can be greatly improved by using Profile:ListenToHopReady() ). If implemented correctly, ProfileService will load profiles as fast as the Roblox API allows it when the player joins a server without a server hop. It's recommended to release profiles right before universe teleports to speed up session lock releasing and further preventing time penalties related to server hopping as much as possible. If your profiles load slower than 7 seconds on a constant basis, continue reading this topic. MAKE SURE YOUR ProfileService MODULE IS UP TO DATE Just to be clear, ProfileService is not a module that trades in speed for security - if implemented properly, your profiles must usually load within 1 to 2 seconds - that's how long a single DataStore UpdateAsync call will take. The problem More often than not, ProfileStore:LoadProfileAsync() is taking a clearly longer than usual amount of time to load, usually 7 seconds or much more. local start_time = tick () ProfileStore : LoadProfileAsync ( profile_key ) print ( tick () - start_time ) --> A value over 10 seconds The culprit Is your code really releasing your profiles after it's done working with them? Are you releasing your profiles immediately after the player leaves the game? If teleporting between places in your game (universe), are you using Profile:ListenToHopReady() ? Functions connected to Players.PlayerRemoving can be tricky to notice errors for because, when testing alone, you will be leaving the game before the errors appear on the developer console . If a player hops to another server ( Server 2 ) before the previous one ( Server 1 ) releases (removes session-lock from) the player's Profile , Server 2 will wait until Server 1 releases the Profile . ProfileService checks the session-lock state of profiles every 7 seconds during a ProfileStore:LoadProfileAsync() call and this will immediately slow down Profile loading very noticably. This is what we would call a race condition . Mistake example #1: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then progile : Release () -- \"progile\" IS A TYPO! end end ) This example would throw an error, though you would need to be inside the server while another player triggers the .PlayerRemoving event. Mistake example #2: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then SaveData ( profile ) -- Are you sure this function doesn't error? profile : Release () end end ) When you're pretty sure you didn't make any typos, the next thing you should check is that nothing can error inside the function connected to .PlayerRemoving . Disclaimer: I don't advise modifying Profile.Data after the player leaves - it's a bad practice in securing your data. You should always store data in a way where unexpectedly losing access to writing to Profile.Data (e.g. server crash) would not cause massive data loss. Mistake example #3: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then wait ( 1 ) -- Or any function with \"Wait\", \"Async\" or \"Yield\" in its name profile : Release () end end ) You should immediately release your profiles after the player leaves ( wait(1) is bad in this example), otherwise you risk creating a race condition where another server that the player joined is trying to load a Profile that hasn't been released yet. Mistake example #4: local profile_key , update_handler -- This simulates excessive UpdateAsync calls for the same Profile key: for i = 1 , 6 do ProfileStore : GlobalUpdateProfileAsync ( profile_key , update_handler ) end Excessive use of ProfileStore:GlobalUpdateProfileAsync() can lead to dead session locks and event lost Profile.Data (latter is mostly possible only if the Profile is loaded in the same session as :GlobalUpdateProfileAsync() is called). This is due to a queue system that executes every write request for the Profile every 7 seconds - if this queue grows larger than the BindToClose timeout (approx. 30 seconds), some requests in the queue can be lost after the game shuts down. How to be sure my profiles are being released? Add a print() : Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then profile : Release () print ( player . Name .. \"'s profile has been released!\" ) end end ) If you're having long Profile loading issues, this is the first thing you should do. Check the developer console for the print and any other possible errors. When ProfileStore:LoadProfileAsync() finishes loading in... less than 2 seconds - You're good! 7 to 30 seconds - Most likely a player server hop race condition (Mistake example #3) Over 60 seconds - The previous server is not releasing the profile / Dead session lock (Mistake examples #1, #2 and #4) DataStore warnings caused by ProfileService \"DataStore request was added to queue. If request queue fills, further requests will be dropped. Try sending fewer requests. Key = XXXXXX\" Is this really bad? If you're only getting one or two warnings every couple of minutes or so, most likely not. Since March 2021 the ProfileService module now uses a custom queue system which greatly reduces Roblox API queue warnings. What does this warning mean? As of writing this guide (July 2020), based on a DevForum thread , Rapid successive UpdateAsync calls will be throttled by the DataStoreService and added to a queue: Throttling queues Every actual budget type (GetAsync, SetIncrementAsync, GetSortedAsync, OnUpdateAsync, SetIncrementSortedAsync) has its own throttling queue. Each of these five throttling queues has a queue size of 30 throttled requests max . Throttled requests are added to the queue of the corresponding budget type that it consumes. When will you get warnings Queue warnings can no longer be caused by faulty use of ProfileService as of March 2021 (Go update now you bastard). I expect these warnings to sometimes pop up during game startup or huge lag spikes / mild API outages.","title":"Troubleshooting"},{"location":"troubleshooting/#problems-in-roblox-studio-testing","text":"By default, data saved with ProfileService in Roblox Studio will not persist. This can be changed by enabling studio access to API services . Warning When studio access to API services is enabled, ProfileService will write to live DataStore keys of the game you're editing (unless ProfileStore.Mock is used) and you might accidentally make unwanted changes to your game's saved data. For more info, check the official documentation .","title":"Problems in Roblox studio testing"},{"location":"troubleshooting/#saving-data-which-roblox-cannot-serialize","text":"I've made the decision to opt-out Profile.Data and Profile.MetaData.MetaTags automatic checking for unserializable data types for efficiency reasons. Consequently, you must be aware of what you MUST AVOID writing inside Profile.Data or Profile.MetaData.MetaTags , directly and inside any nested tables: NaN values - you can check if a number is NaN by comparing it with itself - print(NaN == NaN) --> false (e.g., Profile.Data = {Experience = 0/0} ). NaN values are a result of division by zero and edge cases of some math operations ( math.acos(2) is -NaN ). Table keys that are neither strings nor numbers (e.g., Profile.Data[game.Workspace] = true ). Mixing string keys with number keys within the same table (e.g., Profile.Data = {Coins = 100, [5] = \"yes\"} ). Storing tables with non-sequential indexes (e.g., Profile.Data = {[1] = \"Apple\", [2] = \"Banana\", [3546] = \"Peanut\"} ). If you really have to store non-sequential numbers as indexes, you will have to turn those numbers into string indexes: Profile.Data.Friends[tostring(user_id)] = {GoodFriend = true} . Storing cyclic tables (e.g., Profile.Data = {Self = Profile.Data} ). Storing any userdata including Instance , Vector3 , CFrame , Udim2 , etc. Check whether your value is a userdata by running print(type(value) == \"userdata\") (e.g., Profile.Data = {LastPosition = Vector3.new(0, 0, 0)} ) - For storage, you will have to manually convert your userdata to tables, numbers and strings for storage (e.g., Profile.Data = {LastPosition = {position.X, position.Y, position.Z} } ). This is a limitation of the DataStore API which ProfileService is based on. Warning Failure to prevent these data types may result in silent data loss, silent errors, fatal errors and overall failure to save data.","title":"Saving data which Roblox cannot serialize"},{"location":"troubleshooting/#profiles-take-over-7-seconds-to-load","text":"Notice Due to technical limitations, it's expected that at least 5% of the time, when the player hops servers rapidly, the profile can take up to 7 seconds to load (Can be greatly improved by using Profile:ListenToHopReady() ). If implemented correctly, ProfileService will load profiles as fast as the Roblox API allows it when the player joins a server without a server hop. It's recommended to release profiles right before universe teleports to speed up session lock releasing and further preventing time penalties related to server hopping as much as possible. If your profiles load slower than 7 seconds on a constant basis, continue reading this topic. MAKE SURE YOUR ProfileService MODULE IS UP TO DATE Just to be clear, ProfileService is not a module that trades in speed for security - if implemented properly, your profiles must usually load within 1 to 2 seconds - that's how long a single DataStore UpdateAsync call will take. The problem More often than not, ProfileStore:LoadProfileAsync() is taking a clearly longer than usual amount of time to load, usually 7 seconds or much more. local start_time = tick () ProfileStore : LoadProfileAsync ( profile_key ) print ( tick () - start_time ) --> A value over 10 seconds The culprit Is your code really releasing your profiles after it's done working with them? Are you releasing your profiles immediately after the player leaves the game? If teleporting between places in your game (universe), are you using Profile:ListenToHopReady() ? Functions connected to Players.PlayerRemoving can be tricky to notice errors for because, when testing alone, you will be leaving the game before the errors appear on the developer console . If a player hops to another server ( Server 2 ) before the previous one ( Server 1 ) releases (removes session-lock from) the player's Profile , Server 2 will wait until Server 1 releases the Profile . ProfileService checks the session-lock state of profiles every 7 seconds during a ProfileStore:LoadProfileAsync() call and this will immediately slow down Profile loading very noticably. This is what we would call a race condition . Mistake example #1: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then progile : Release () -- \"progile\" IS A TYPO! end end ) This example would throw an error, though you would need to be inside the server while another player triggers the .PlayerRemoving event. Mistake example #2: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then SaveData ( profile ) -- Are you sure this function doesn't error? profile : Release () end end ) When you're pretty sure you didn't make any typos, the next thing you should check is that nothing can error inside the function connected to .PlayerRemoving . Disclaimer: I don't advise modifying Profile.Data after the player leaves - it's a bad practice in securing your data. You should always store data in a way where unexpectedly losing access to writing to Profile.Data (e.g. server crash) would not cause massive data loss. Mistake example #3: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then wait ( 1 ) -- Or any function with \"Wait\", \"Async\" or \"Yield\" in its name profile : Release () end end ) You should immediately release your profiles after the player leaves ( wait(1) is bad in this example), otherwise you risk creating a race condition where another server that the player joined is trying to load a Profile that hasn't been released yet. Mistake example #4: local profile_key , update_handler -- This simulates excessive UpdateAsync calls for the same Profile key: for i = 1 , 6 do ProfileStore : GlobalUpdateProfileAsync ( profile_key , update_handler ) end Excessive use of ProfileStore:GlobalUpdateProfileAsync() can lead to dead session locks and event lost Profile.Data (latter is mostly possible only if the Profile is loaded in the same session as :GlobalUpdateProfileAsync() is called). This is due to a queue system that executes every write request for the Profile every 7 seconds - if this queue grows larger than the BindToClose timeout (approx. 30 seconds), some requests in the queue can be lost after the game shuts down. How to be sure my profiles are being released? Add a print() : Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then profile : Release () print ( player . Name .. \"'s profile has been released!\" ) end end ) If you're having long Profile loading issues, this is the first thing you should do. Check the developer console for the print and any other possible errors. When ProfileStore:LoadProfileAsync() finishes loading in... less than 2 seconds - You're good! 7 to 30 seconds - Most likely a player server hop race condition (Mistake example #3) Over 60 seconds - The previous server is not releasing the profile / Dead session lock (Mistake examples #1, #2 and #4)","title":"Profiles take over 7 seconds to load"},{"location":"troubleshooting/#datastore-warnings-caused-by-profileservice","text":"\"DataStore request was added to queue. If request queue fills, further requests will be dropped. Try sending fewer requests. Key = XXXXXX\" Is this really bad? If you're only getting one or two warnings every couple of minutes or so, most likely not. Since March 2021 the ProfileService module now uses a custom queue system which greatly reduces Roblox API queue warnings. What does this warning mean? As of writing this guide (July 2020), based on a DevForum thread , Rapid successive UpdateAsync calls will be throttled by the DataStoreService and added to a queue: Throttling queues Every actual budget type (GetAsync, SetIncrementAsync, GetSortedAsync, OnUpdateAsync, SetIncrementSortedAsync) has its own throttling queue. Each of these five throttling queues has a queue size of 30 throttled requests max . Throttled requests are added to the queue of the corresponding budget type that it consumes. When will you get warnings Queue warnings can no longer be caused by faulty use of ProfileService as of March 2021 (Go update now you bastard). I expect these warnings to sometimes pop up during game startup or huge lag spikes / mild API outages.","title":"DataStore warnings caused by ProfileService"},{"location":"tutorial/basic_usage/","text":"Most of the work with ProfileService is setting up your data loading code. Afterwards, data is read and written directly to the Profile.Data table without the necessity to use any ProfileService method calls - you set up your own read / write functions, wrappers, classes with profiles as components, etc! The code below is a basic profile loader implementation for ProfileService: Note Unlike most custom DataStore modules where you would listen for Players.PlayerRemoving to clean up, ProfileService may release (destroy) the profile before the player leaves the server - this has to be handled by using Profile:ListenToRelease(listener_function) - any amount of functions can be added! -- ProfileTemplate table is what empty profiles will default to. -- Updating the template will not include missing template values -- in existing player profiles! local ProfileTemplate = { Cash = 0 , Items = {}, LogInTimes = 0 , } ----- Loaded Modules ----- local ProfileService = require ( game . ServerScriptService . ProfileService ) ----- Private Variables ----- local Players = game : GetService ( \"Players\" ) local ProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) local Profiles = {} -- [player] = profile ----- Private Functions ----- local function GiveCash ( profile , amount ) -- If \"Cash\" was not defined in the ProfileTemplate at game launch, -- you will have to perform the following: if profile . Data . Cash == nil then profile . Data . Cash = 0 end -- Increment the \"Cash\" value: profile . Data . Cash = profile . Data . Cash + amount end local function DoSomethingWithALoadedProfile ( player , profile ) profile . Data . LogInTimes = profile . Data . LogInTimes + 1 print ( player . Name .. \" has logged in \" .. tostring ( profile . Data . LogInTimes ) .. \" time\" .. (( profile . Data . LogInTimes > 1 ) and \"s\" or \"\" )) GiveCash ( profile , 100 ) print ( player . Name .. \" owns \" .. tostring ( profile . Data . Cash ) .. \" now!\" ) end local function PlayerAdded ( player ) local profile = ProfileStore : LoadProfileAsync ( \"Player_\" .. player . UserId ) if profile ~= nil then profile : AddUserId ( player . UserId ) -- GDPR compliance profile : Reconcile () -- Fill in missing variables from ProfileTemplate (optional) profile : ListenToRelease ( function () Profiles [ player ] = nil -- The profile could've been loaded on another Roblox server: player : Kick () end ) if player : IsDescendantOf ( Players ) == true then Profiles [ player ] = profile -- A profile has been successfully loaded: DoSomethingWithALoadedProfile ( player , profile ) else -- Player left before the profile loaded: profile : Release () end else -- The profile couldn't be loaded possibly due to other -- Roblox servers trying to load this profile at the same time: player : Kick () end end ----- Initialize ----- -- In case Players have joined the server earlier than this script ran: for _ , player in ipairs ( Players : GetPlayers ()) do coroutine.wrap ( PlayerAdded )( player ) end ----- Connections ----- Players . PlayerAdded : Connect ( PlayerAdded ) Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then profile : Release () end end )","title":"Basic Usage"},{"location":"tutorial/developer_products/","text":"The following example features code that would reliably handle developer product purchases through the ProcessReceipt callback. We yield the ProcessReceipt callback until we know that the purchase was successfully saved to the DataStore or until the player leaves and triggers a profile release. local SETTINGS = { ProfileTemplate = { Cash = 0 , }, Products = { -- developer_product_id = function(profile) [ 97662780 ] = function ( profile ) profile . Data . Cash += 100 end , [ 97663121 ] = function ( profile ) profile . Data . Cash += 1000 end , }, PurchaseIdLog = 50 , -- Store this amount of purchase id's in MetaTags; -- This value must be reasonably big enough so the player would not be able -- to purchase products faster than individual purchases can be confirmed. -- Anything beyond 30 should be good enough. } ----- Loaded Modules ----- local ProfileService = require ( game . ServerScriptService . ProfileService ) ----- Private Variables ----- local Players = game : GetService ( \"Players\" ) local MarketplaceService = game : GetService ( \"MarketplaceService\" ) local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , SETTINGS . ProfileTemplate ) local Profiles = {} -- {player = profile, ...} ----- Private Functions ----- local function PlayerAdded ( player ) local profile = GameProfileStore : LoadProfileAsync ( \"Player_\" .. player . UserId ) if profile ~= nil then profile : AddUserId ( player . UserId ) -- GDPR compliance profile : Reconcile () -- Fill in missing variables from ProfileTemplate (optional) profile : ListenToRelease ( function () Profiles [ player ] = nil player : Kick () -- The profile could've been loaded on another Roblox server end ) if player : IsDescendantOf ( Players ) == true then Profiles [ player ] = profile else profile : Release () -- Player left before the profile loaded end else -- The profile couldn't be loaded possibly due to other -- Roblox servers trying to load this profile at the same time: player : Kick () end end function PurchaseIdCheckAsync ( profile , purchase_id , grant_product_callback ) --> Enum.ProductPurchaseDecision -- Yields until the purchase_id is confirmed to be saved to the profile or the profile is released if profile : IsActive () ~= true then return Enum . ProductPurchaseDecision . NotProcessedYet else local meta_data = profile . MetaData local local_purchase_ids = meta_data . MetaTags . ProfilePurchaseIds if local_purchase_ids == nil then local_purchase_ids = {} meta_data . MetaTags . ProfilePurchaseIds = local_purchase_ids end -- Granting product if not received: if table . find ( local_purchase_ids , purchase_id ) == nil then while # local_purchase_ids >= SETTINGS . PurchaseIdLog do table.remove ( local_purchase_ids , 1 ) end table.insert ( local_purchase_ids , purchase_id ) coroutine.wrap ( grant_product_callback )() end -- Waiting until the purchase is confirmed to be saved: local result = nil local function check_latest_meta_tags () local saved_purchase_ids = meta_data . MetaTagsLatest . ProfilePurchaseIds if saved_purchase_ids ~= nil and table . find ( saved_purchase_ids , purchase_id ) ~= nil then result = Enum . ProductPurchaseDecision . PurchaseGranted end end check_latest_meta_tags () local meta_tags_connection = profile . MetaTagsUpdated : Connect ( function () check_latest_meta_tags () -- When MetaTagsUpdated fires after profile release: if profile : IsActive () == false and result == nil then result = Enum . ProductPurchaseDecision . NotProcessedYet end end ) while result == nil do task . wait () end meta_tags_connection : Disconnect () return result end end local function GetPlayerProfileAsync ( player ) --> [Profile] / nil -- Yields until a Profile linked to a player is loaded or the player leaves local profile = Profiles [ player ] while profile == nil and player : IsDescendantOf ( Players ) == true do task . wait () profile = Profiles [ player ] end return profile end local function GrantProduct ( player , product_id ) -- We shouldn't yield during the product granting process! local profile = Profiles [ player ] local product_function = SETTINGS . Products [ product_id ] if product_function ~= nil then product_function ( profile ) else warn ( \"ProductId \" .. tostring ( product_id ) .. \" has not been defined in Products table\" ) end end local function ProcessReceipt ( receipt_info ) local player = Players : GetPlayerByUserId ( receipt_info . PlayerId ) if player == nil then return Enum . ProductPurchaseDecision . NotProcessedYet end local profile = GetPlayerProfileAsync ( player ) if profile ~= nil then return PurchaseIdCheckAsync ( profile , receipt_info . PurchaseId , function () GrantProduct ( player , receipt_info . ProductId ) end ) else return Enum . ProductPurchaseDecision . NotProcessedYet end end ----- Initialize ----- for _ , player in ipairs ( Players : GetPlayers ()) do coroutine.wrap ( PlayerAdded )( player ) end MarketplaceService . ProcessReceipt = ProcessReceipt ----- Connections ----- Players . PlayerAdded : Connect ( PlayerAdded ) Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then profile : Release () end end )","title":"Developer Products"},{"location":"tutorial/settingup/","text":"ProfileService is supposed to be a ModuleScript which you can place inside your Roblox game's ServerScriptService or wherever else is preferred. ProfileService can only be used server-side Option #1: Get ProfileService from the Roblox library Get the library model here Move \"ProfileService\" ModuleScript to ServerScriptService: Option #2: Github ProfileService repository","title":"Setting up"},{"location":"tutorial/settingup/#option-1-get-profileservice-from-the-roblox-library","text":"Get the library model here Move \"ProfileService\" ModuleScript to ServerScriptService:","title":"Option #1: Get ProfileService from the Roblox library"},{"location":"tutorial/settingup/#option-2-github","text":"ProfileService repository","title":"Option #2: Github"}]}